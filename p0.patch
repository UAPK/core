--- a/backend/alembic/versions/20251216_000000_0006_approval_consumption.py
+++ b/backend/alembic/versions/20251216_000000_0006_approval_consumption.py
@@ -0,0 +1,34 @@
+"""Add one-time override token consumption tracking.
+
+Revision ID: 0006
+Revises: 0005
+Create Date: 2025-12-16 00:00:00.000000
+
+"""
+
+from typing import Sequence, Union
+
+import sqlalchemy as sa
+from alembic import op
+
+# revision identifiers, used by Alembic.
+revision: str = "0006"
+down_revision: Union[str, None] = "0005"
+branch_labels: Union[str, Sequence[str], None] = None
+depends_on: Union[str, Sequence[str], None] = None
+
+
+def upgrade() -> None:
+    op.add_column(
+        "approvals",
+        sa.Column("consumed_at", sa.DateTime(timezone=True), nullable=True),
+    )
+    op.add_column(
+        "approvals",
+        sa.Column("consumed_interaction_id", sa.String(length=64), nullable=True),
+    )
+
+
+def downgrade() -> None:
+    op.drop_column("approvals", "consumed_interaction_id")
+    op.drop_column("approvals", "consumed_at")
--- a/backend/app/api/v1/actions.py
+++ b/backend/app/api/v1/actions.py
@@ -10,12 +10,16 @@

 from app.api.deps import DbSession
 from app.schemas.action import ActionRequest, ActionResponse
-from app.services.action_gateway import ActionGatewayService

 router = APIRouter(prefix="/actions", tags=["Actions"])


-@router.post("", response_model=ActionResponse)
+@router.post(
+    "",
+    response_model=ActionResponse,
+    deprecated=True,
+    include_in_schema=False,
+)
 async def submit_action(
     request: ActionRequest,
     db: DbSession,
@@ -42,35 +46,14 @@
     - `approved`: Action is allowed, proceed with execution
     - `denied`: Action is blocked by policy or capability limits
     - `pending`: Action requires human approval before proceeding
     """
-    if authorization is None:
-        raise HTTPException(
-            status_code=status.HTTP_401_UNAUTHORIZED,
-            detail="Authorization header required",
-            headers={"WWW-Authenticate": "Bearer"},
-        )
-
-    # Extract Bearer token
-    parts = authorization.split()
-    if len(parts) != 2 or parts[0].lower() != "bearer":
-        raise HTTPException(
-            status_code=status.HTTP_401_UNAUTHORIZED,
-            detail="Invalid authorization header format. Expected: Bearer <token>",
-            headers={"WWW-Authenticate": "Bearer"},
-        )
-
-    jwt_token = parts[1]
-
-    gateway = ActionGatewayService(db)
-    return await gateway.process_action(jwt_token, request)
+    raise HTTPException(
+        status_code=status.HTTP_410_GONE,
+        detail=(
+            "This endpoint is deprecated. Use /api/v1/gateway/evaluate or "
+            "/api/v1/gateway/execute with the GatewayActionRequest schema."
+        ),
+    )
--- a/backend/app/api/v1/capabilities.py
+++ b/backend/app/api/v1/capabilities.py
@@ -78,7 +78,7 @@
     key_manager = get_gateway_key_manager()
     return GatewayPublicKeyResponse(
         issuer_id="gateway",
-        public_key=key_manager.get_public_key_base64(),
+        public_key=key_manager.public_key_base64,
         algorithm="EdDSA",
     )
--- a/backend/app/core/action_hash.py
+++ b/backend/app/core/action_hash.py
@@ -0,0 +1,25 @@
+"""Deterministic action hashing utilities.
+
+Used to bind short-lived override tokens to *exactly one* approved action
+payload (type/tool/params), preventing token reuse for a different action.
+
+The hash must be:
+- Deterministic (stable ordering)
+- JSON-compatible
+- Fast to compute
+"""
+
+from __future__ import annotations
+
+import hashlib
+import json
+from typing import Any
+
+
+def compute_action_hash(action: dict[str, Any]) -> str:
+    """Compute a deterministic SHA-256 hash of an action dict."""
+    canonical = json.dumps(action, sort_keys=True, separators=(",", ":"))
+    return hashlib.sha256(canonical.encode()).hexdigest()
--- a/backend/app/gateway/connectors/webhook.py
+++ b/backend/app/gateway/connectors/webhook.py
@@ -1,13 +1,15 @@
 """Webhook connector - POST to configured URL."""

 import time
 from typing import Any
+from urllib.parse import urlparse

 import httpx

+from app.core.config import get_settings
 from app.gateway.connectors.base import ConnectorConfig, ConnectorResult, ToolConnector


 class WebhookConnector(ToolConnector):
     """Webhook connector - sends POST request to a configured URL."""

     def __init__(self, config: ConnectorConfig, secrets: dict[str, str] | None = None) -> None:
         super().__init__(config, secrets)
         if not config.url:
             raise ValueError("Webhook connector requires URL")
         self.client = httpx.AsyncClient(timeout=self.config.timeout_seconds)
+        self.settings = get_settings()
+
+    def _get_allowed_domains(self) -> list[str]:
+        """Get allowed domains from connector config or global settings."""
+        if self.config.extra and self.config.extra.get("allowed_domains"):
+            return self.config.extra["allowed_domains"]
+        return self.settings.gateway_allowed_webhook_domains
+
+    def _validate_url(self, url: str) -> tuple[bool, str | None]:
+        """Validate URL against allowlist to prevent SSRF."""
+        allowed_domains = self._get_allowed_domains()
+        if not allowed_domains:
+            return False, "No allowed webhook domains configured"
+
+        parsed = urlparse(url)
+        if parsed.scheme not in ("http", "https"):
+            return False, f"Invalid URL scheme: {parsed.scheme}"
+
+        domain = parsed.hostname
+        if not domain:
+            return False, "Could not extract hostname from URL"
+
+        domain = domain.lower()
+        allowed_lower = [d.lower() for d in allowed_domains]
+
+        for allowed in allowed_lower:
+            if domain == allowed or domain.endswith(f".{allowed}"):
+                return True, None
+
+        return False, f"Domain '{domain}' not in allowed domains list"

     async def execute(self, payload: dict[str, Any]) -> ConnectorResult:
         """Execute webhook call."""
+        ok, error = self._validate_url(self.config.url)
+        if not ok:
+            return ConnectorResult(
+                success=False,
+                error={"code": "DOMAIN_NOT_ALLOWED", "message": error},
+            )
+
         start_time = time.time()

         # Build request
         headers = self.config.headers.copy()

         # Add secrets to headers if specified
         for key, value in self.secrets.items():
             if key.startswith("header:"):
                 header_name = key.split(":", 1)[1]
                 headers[header_name] = value

         try:
             response = await self.client.request(
                 method=self.config.method,
                 url=self.config.url,
                 json=payload,
                 headers=headers,
             )

             duration_ms = int((time.time() - start_time) * 1000)

             if response.status_code >= 400:
                 return ConnectorResult(
                     success=False,
                     error={
                         "code": "WEBHOOK_ERROR",
                         "message": f"Webhook returned {response.status_code}",
                         "status_code": response.status_code,
                         "response": response.text[:500],  # Limit response size
                     },
                     duration_ms=duration_ms,
                 )

             return ConnectorResult(
                 success=True,
                 data=response.json() if response.headers.get("content-type", "").startswith("application/json") else {"response": response.text},
                 duration_ms=duration_ms,
             )

         except httpx.TimeoutException:
             duration_ms = int((time.time() - start_time) * 1000)
             return ConnectorResult(
                 success=False,
                 error={"code": "TIMEOUT", "message": "Webhook request timed out"},
                 duration_ms=duration_ms,
             )

         except Exception as e:
             duration_ms = int((time.time() - start_time) * 1000)
             return ConnectorResult(
                 success=False,
                 error={"code": "ERROR", "message": str(e)},
                 duration_ms=duration_ms,
             )
--- a/backend/app/gateway/policy_engine.py
+++ b/backend/app/gateway/policy_engine.py
@@ -9,11 +9,13 @@
 from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
 from sqlalchemy import select
 from sqlalchemy.dialects.postgresql import insert
 from sqlalchemy.ext.asyncio import AsyncSession

+from app.core.action_hash import compute_action_hash
 from app.core.capability_jwt import CapabilityTokenClaims, verify_capability_token
 from app.core.config import get_settings
 from app.core.ed25519 import public_key_from_base64
 from app.core.logging import get_logger
 from app.models.action_counter import ActionCounter
+from app.models.approval import Approval, ApprovalStatus
 from app.models.capability_issuer import CapabilityIssuer, IssuerStatus
 from app.models.uapk_manifest import ManifestStatus, UapkManifest
 from app.schemas.gateway import (
     ActionInfo,
@@ -51,6 +53,7 @@
     decision: GatewayDecision
     reasons: list[ReasonDetail] = field(default_factory=list)
     manifest: UapkManifest | None = None
+    token_claims: CapabilityTokenClaims | None = None
     budget_count: int = 0
     budget_limit: int = 0
     policy_trace: list[dict] = field(default_factory=list)
@@ -131,6 +134,36 @@
         else:
             result.add_trace("capability_token_validation", "skip", {"reason": "no_token_provided"})

+        # 2b. If the capability token is an override token, validate it.
+        # NOTE: Validation is side-effect free. Consumption (one-time use) is
+        # enforced in the execute flow.
+        override_valid = False
+        if context.token_claims and context.token_claims.approval_id and context.token_claims.action_hash:
+            override_valid = await self._validate_override_token(context, result)
+            if not override_valid:
+                result.decision = GatewayDecision.DENY
+                result.add_trace(
+                    "override_token_validation",
+                    "fail",
+                    {
+                        "approval_id": context.token_claims.approval_id,
+                    },
+                )
+                return result
+            result.add_trace(
+                "override_token_validation",
+                "pass",
+                {
+                    "approval_id": context.token_claims.approval_id,
+                },
+            )
+        else:
+            result.add_trace(
+                "override_token_validation",
+                "skip",
+                {"reason": "not_override_token"},
+            )
+
         # Extract policy config from manifest
         manifest_json = manifest.manifest_json
         constraints = manifest_json.get("constraints", {})
         policy_config = manifest_json.get("policy", {})
@@ -294,10 +327,22 @@
         # Store risk indicators
         result.risk_indicators["budget_current"] = result.budget_count
         result.risk_indicators["budget_limit"] = result.budget_limit

+        # Apply override token to bypass ESCALATE decisions (human already approved)
+        if override_valid and result.decision == GatewayDecision.ESCALATE:
+            result.decision = GatewayDecision.ALLOW
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_ACCEPTED,
+                "Override token accepted; required approval already granted",
+                {"approval_id": context.token_claims.approval_id if context.token_claims else None},
+            )
+            result.add_trace("override_token_applied", "pass")
+
         # If we get here with ALLOW, add success reason
-        if result.decision == GatewayDecision.ALLOW:
+        if result.decision == GatewayDecision.ALLOW and not override_valid:
             result.add_reason(
                 ReasonCode.ALL_CHECKS_PASSED,
                 "All policy checks passed",
@@ -607,6 +652,7 @@
             )
             return False

         # Store claims in context for later checks
         context.token_claims = claims
+        result.token_claims = claims

         # Verify token is for this org
         if claims.org_id != str(context.org_id):
@@ -694,6 +740,101 @@

         return True

+    async def _validate_override_token(
+        self,
+        context: PolicyContext,
+        result: PolicyResult,
+    ) -> bool:
+        """Validate that an override token is bound to a specific approved action.
+
+        This check is intentionally **side-effect free**: it does not mark an
+        approval as consumed. Consumption is enforced in the execute flow to
+        avoid mutating state on evaluate() requests.
+        """
+        claims = context.token_claims
+        if not claims or not claims.approval_id or not claims.action_hash:
+            return True  # Not an override token
+
+        # 1) Action hash must match the current request action
+        request_action_hash = compute_action_hash(context.action.model_dump())
+        if request_action_hash != claims.action_hash:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_INVALID,
+                "Override token does not match requested action",
+                {
+                    "expected_action_hash": claims.action_hash,
+                    "actual_action_hash": request_action_hash,
+                },
+            )
+            return False
+
+        # 2) Approval must exist and be approved
+        approval_result = await self.db.execute(
+            select(Approval).where(
+                Approval.org_id == context.org_id,
+                Approval.approval_id == claims.approval_id,
+            )
+        )
+        approval = approval_result.scalar_one_or_none()
+        if approval is None:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_INVALID,
+                f"Approval '{claims.approval_id}' not found",
+                {"approval_id": claims.approval_id},
+            )
+            return False
+
+        if approval.status != ApprovalStatus.APPROVED:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_INVALID,
+                f"Approval '{claims.approval_id}' is not approved (status: {approval.status.value})",
+                {"status": approval.status.value},
+            )
+            return False
+
+        now = datetime.now(UTC)
+        if approval.expires_at and approval.expires_at < now:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_INVALID,
+                f"Approval '{claims.approval_id}' has expired",
+                {"expires_at": approval.expires_at.isoformat()},
+            )
+            return False
+
+        # 3) Approval identity must match this request
+        if approval.uapk_id != context.uapk_id or approval.agent_id != context.agent_id:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_INVALID,
+                "Approval identity does not match request",
+                {
+                    "approval_uapk_id": approval.uapk_id,
+                    "request_uapk_id": context.uapk_id,
+                    "approval_agent_id": approval.agent_id,
+                    "request_agent_id": context.agent_id,
+                },
+            )
+            return False
+
+        # 4) One-time-use: must not be consumed already
+        if getattr(approval, "consumed_at", None) is not None:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_ALREADY_USED,
+                f"Approval '{claims.approval_id}' already consumed",
+                {
+                    "consumed_at": approval.consumed_at.isoformat() if approval.consumed_at else None,
+                    "consumed_interaction_id": approval.consumed_interaction_id,
+                },
+            )
+            return False
+
+        # 5) Approval action hash must match token hash (defense-in-depth)
+        approval_action_hash = compute_action_hash(approval.action)
+        if approval_action_hash != claims.action_hash:
+            result.add_reason(
+                ReasonCode.OVERRIDE_TOKEN_INVALID,
+                "Approval action does not match override token",
+                {
+                    "approval_action_hash": approval_action_hash,
+                    "token_action_hash": claims.action_hash,
+                },
+            )
+            return False
+
+        return True
+
     async def _get_issuer_public_keys(
         self,
         org_id: UUID,
--- a/backend/app/gateway/service.py
+++ b/backend/app/gateway/service.py
@@ -6,7 +6,7 @@
 from typing import Any
 from uuid import UUID

-from sqlalchemy import desc, select
+from sqlalchemy import desc, select, update
 from sqlalchemy.ext.asyncio import AsyncSession

 from app.core.audit import (
     canonicalize_json,
@@ -184,9 +184,41 @@
         tool_result: ToolResult | None = None
         approval_id: str | None = None

         if policy_result.decision == GatewayDecision.ALLOW:
+            # If this ALLOW is being authorized via an override token,
+            # enforce one-time-use by atomically consuming the underlying approval.
+            if (
+                policy_result.token_claims
+                and policy_result.token_claims.approval_id
+                and policy_result.token_claims.action_hash
+            ):
+                consumed_ok = await self._consume_override_approval(
+                    org_id=org_id,
+                    approval_id=policy_result.token_claims.approval_id,
+                    interaction_id=interaction_id,
+                )
+                if not consumed_ok:
+                    # Race condition or replay attempt. Do not execute.
+                    policy_result.decision = GatewayDecision.DENY
+                    policy_result.add_reason(
+                        ReasonCode.OVERRIDE_TOKEN_ALREADY_USED,
+                        "Override approval has already been consumed",
+                        {
+                            "approval_id": policy_result.token_claims.approval_id,
+                        },
+                    )
+
             # Execute the tool
-            executed = True
-            connector_result = await self._execute_tool(
-                org_id=org_id,
-                manifest=policy_result.manifest,
-                request=request,
-            )
+            if policy_result.decision == GatewayDecision.ALLOW:
+                executed = True
+                connector_result = await self._execute_tool(
+                    org_id=org_id,
+                    manifest=policy_result.manifest,
+                    request=request,
+                )

-            tool_result = ToolResult(
-                success=connector_result.success,
-                data=connector_result.data,
-                error=connector_result.error,
-                result_hash=connector_result.result_hash,
-                duration_ms=connector_result.duration_ms,
-            )
+                tool_result = ToolResult(
+                    success=connector_result.success,
+                    data=connector_result.data,
+                    error=connector_result.error,
+                    result_hash=connector_result.result_hash,
+                    duration_ms=connector_result.duration_ms,
+                )

-            # Increment budget counter
-            await self.policy_engine.increment_budget(org_id, request.uapk_id)
+                # Increment budget counter
+                await self.policy_engine.increment_budget(org_id, request.uapk_id)

         elif policy_result.decision == GatewayDecision.ESCALATE:
             approval_id = await self._create_approval(
                 org_id=org_id,
@@ -375,6 +407,39 @@
         )

         return approval_id

+    async def _consume_override_approval(
+        self,
+        org_id: UUID,
+        approval_id: str,
+        interaction_id: str,
+    ) -> bool:
+        """Mark an approved approval as consumed (one-time override token).
+
+        This is enforced atomically to prevent races/replays:
+        only one execute() request may successfully consume a given approval.
+        """
+        now = datetime.now(UTC)
+
+        stmt = (
+            update(Approval)
+            .where(
+                Approval.org_id == org_id,
+                Approval.approval_id == approval_id,
+                Approval.status == ApprovalStatus.APPROVED,
+                Approval.consumed_at.is_(None),
+            )
+            .values(consumed_at=now, consumed_interaction_id=interaction_id)
+            .returning(Approval.id)
+        )
+
+        result = await self.db.execute(stmt)
+        updated_id = result.scalar_one_or_none()
+        if updated_id is None:
+            await self.db.rollback()
+            return False
+
+        await self.db.commit()
+        return True
+
     async def _create_interaction_record(
         self,
         org_id: UUID,
--- a/backend/app/models/approval.py
+++ b/backend/app/models/approval.py
@@ -46,6 +46,17 @@
     decision_notes: Mapped[str | None] = mapped_column(Text, nullable=True)

+    # Override token consumption (one-time-use enforcement)
+    consumed_at: Mapped[datetime | None] = mapped_column(
+        DateTime(timezone=True),
+        nullable=True,
+    )
+    consumed_interaction_id: Mapped[str | None] = mapped_column(
+        String(64),
+        nullable=True,
+    )
+
     created_at: Mapped[datetime] = mapped_column(
         DateTime(timezone=True), server_default=func.now()
     )
--- a/backend/app/models/user.py
+++ b/backend/app/models/user.py
@@ -68,6 +68,20 @@
     memberships: Mapped[list["Membership"]] = relationship(  # noqa: F821
         "Membership",
         back_populates="user",
         cascade="all, delete-orphan",
     )
+
+    @property
+    def default_org_id(self) -> uuid.UUID | None:
+        """Best-effort default organization for legacy routes.
+
+        Several API and UI routes currently assume a "default" organization and
+        access `current_user.default_org_id`. This property is a compatibility
+        shim until all routes are fully org-scoped.
+        """
+        if not self.memberships:
+            return None
+        return self.memberships[0].org_id
--- a/backend/app/schemas/gateway.py
+++ b/backend/app/schemas/gateway.py
@@ -22,6 +22,7 @@
     # Allow reasons
     POLICY_PASSED = "policy_passed"
     ALL_CHECKS_PASSED = "all_checks_passed"
+    OVERRIDE_TOKEN_ACCEPTED = "override_token_accepted"

     # Deny reasons
     MANIFEST_NOT_FOUND = "manifest_not_found"
@@ -36,6 +37,10 @@
     CAPABILITY_NOT_GRANTED = "capability_not_granted"
     INVALID_REQUEST = "invalid_request"

+    # Override token deny reasons
+    OVERRIDE_TOKEN_INVALID = "override_token_invalid"
+    OVERRIDE_TOKEN_ALREADY_USED = "override_token_already_used"
+
     # Capability token deny reasons
     CAPABILITY_TOKEN_INVALID = "capability_token_invalid"
     CAPABILITY_TOKEN_EXPIRED = "capability_token_expired"
--- a/backend/app/schemas/manifest.py
+++ b/backend/app/schemas/manifest.py
@@ -1,9 +1,12 @@
 """Manifest schema definitions."""

 from datetime import datetime
 from typing import Any
 from uuid import UUID

 from pydantic import BaseModel, Field

@@ -71,6 +74,66 @@
 class ManifestMetadata(BaseModel):
     """Additional metadata about the manifest."""

     created_at: datetime | None = None
     updated_at: datetime | None = None
     source: str | None = None
+
+
+class ManifestPolicy(BaseModel):
+    """Policy configuration used by the Agent Interaction Gateway.
+
+    This is intentionally permissive: policy keys evolve over time and
+    manifests may carry additional fields for downstream components.
+    """
+
+    model_config = {"extra": "allow"}
+
+    allowed_action_types: list[str] | None = None
+    allowed_tools: list[str] | None = None
+    denied_tools: list[str] | None = None
+    allowed_jurisdictions: list[str] | None = None
+    counterparty: dict[str, Any] | None = None
+    amount_caps: dict[str, Any] | None = None
+
+
+class ManifestToolConfig(BaseModel):
+    """Tool connector configuration used by the gateway executor."""
+
+    model_config = {"extra": "allow"}
+
+    connector_type: str | None = Field(
+        None,
+        description="Connector type (mock|webhook|http|http_request)",
+    )
+    url: str | None = None
+    method: str | None = None
+    headers: dict[str, str] = Field(default_factory=dict)
+    timeout_seconds: int | None = Field(None, ge=1, le=300)
+    secret_refs: dict[str, str] = Field(default_factory=dict)
+    extra: dict[str, Any] = Field(default_factory=dict)


 class ManifestContent(BaseModel):
     """The core manifest content."""

+    # Allow unknown fields so the manifest format can evolve without breaking
+    # older gateway deployments.
+    model_config = {"extra": "allow"}
+
     agent: AgentInfo
     capabilities: list[CapabilityInfo] = Field(default_factory=list)
     constraints: ManifestConstraints = Field(default_factory=ManifestConstraints)
+    policy: ManifestPolicy | None = None
+    tools: dict[str, ManifestToolConfig] | None = None
+    default_connector: ManifestToolConfig | None = None
     metadata: ManifestMetadata = Field(default_factory=ManifestMetadata)
--- a/backend/app/services/approval.py
+++ b/backend/app/services/approval.py
@@ -1,9 +1,9 @@
 """Service layer for approval workflow."""

 from datetime import UTC, datetime
 from typing import Any
 from uuid import UUID

 from sqlalchemy import select
 from sqlalchemy.ext.asyncio import AsyncSession

+from app.core.action_hash import compute_action_hash
 from app.core.capability_jwt import create_override_token
 from app.core.logging import get_logger
 from app.models.approval import Approval, ApprovalStatus
@@ -205,7 +205,7 @@
     async def approve_action(
         self,
         org_id: UUID,
         approval_id: str,
@@ -216,7 +216,7 @@
         if approval is None:
             raise ApprovalNotFoundError(f"Approval {approval_id} not found")

         # Compute action hash for token binding
-        action_hash = _compute_action_hash(approval.action)
+        action_hash = compute_action_hash(approval.action)

         # Update approval status
         approval.status = ApprovalStatus.APPROVED
@@ -316,17 +316,6 @@
         return ApprovalStats(
             total_pending=total_pending,
             total_approved=total_approved,
             total_denied=total_denied,
             avg_response_time_seconds=avg_response_time,
         )
-
-
-def _compute_action_hash(action: dict) -> str:
-    """Compute a hash of the action for override token binding."""
-    # Sort keys for deterministic hashing
-    action_json = json.dumps(action, sort_keys=True, separators=(",", ":"))
-    return hashlib.sha256(action_json.encode()).hexdigest()[:16]
--- a/backend/app/services/auth.py
+++ b/backend/app/services/auth.py
@@ -38,7 +38,11 @@
     async def get_user_by_id(self, user_id: UUID) -> User | None:
         """Get a user by their ID."""
-        result = await self.db.execute(select(User).where(User.id == user_id))
+        # Load memberships eagerly so legacy routes that rely on user.default_org_id
+        # won't trigger lazy-loading outside the request/session scope.
+        result = await self.db.execute(
+            select(User).options(selectinload(User.memberships)).where(User.id == user_id)
+        )
         return result.scalar_one_or_none()
--- a/schemas/manifest.v1.schema.json
+++ b/schemas/manifest.v1.schema.json
@@ -74,6 +74,62 @@
     "constraints": {
       "type": "object",
       "description": "Self-imposed constraints",
       "properties": {
@@ -97,6 +153,50 @@
         }
       }
     },
+    "policy": {
+      "type": "object",
+      "description": "Gateway policy configuration (optional)",
+      "properties": {
+        "allowed_action_types": {
+          "type": "array",
+          "items": {"type": "string"}
+        },
+        "allowed_tools": {
+          "type": "array",
+          "items": {"type": "string"}
+        },
+        "denied_tools": {
+          "type": "array",
+          "items": {"type": "string"}
+        },
+        "allowed_jurisdictions": {
+          "type": "array",
+          "items": {"type": "string"}
+        },
+        "counterparty": {
+          "type": "object",
+          "properties": {
+            "allowlist": {"type": "array", "items": {"type": "string"}},
+            "denylist": {"type": "array", "items": {"type": "string"}}
+          },
+          "additionalProperties": true
+        },
+        "amount_caps": {
+          "type": "object",
+          "properties": {
+            "param_paths": {"type": "array", "items": {"type": "string"}},
+            "max_amount": {"type": "number"},
+            "escalate_above": {"type": "number"},
+            "currency_field": {"type": "string"}
+          },
+          "additionalProperties": true
+        }
+      },
+      "additionalProperties": true
+    },
+    "tools": {
+      "type": "object",
+      "description": "Tool registry: tool_name -> connector config (optional)",
+      "additionalProperties": {"$ref": "#/$defs/tool"}
+    },
+    "default_connector": {
+      "$ref": "#/$defs/tool",
+      "description": "Optional default connector config when a tool has no explicit entry"
+    },
     "metadata": {
       "type": "object",
       "description": "Additional metadata",
@@ -125,5 +181,35 @@
         }
       }
     }
+  },
+  "$defs": {
+    "tool": {
+      "type": "object",
+      "description": "Connector configuration for a tool",
+      "properties": {
+        "connector_type": {
+          "type": "string",
+          "description": "Connector type (mock|webhook|http|http_request)"
+        },
+        "url": {"type": "string", "format": "uri"},
+        "method": {"type": "string"},
+        "headers": {
+          "type": "object",
+          "additionalProperties": {"type": "string"}
+        },
+        "timeout_seconds": {"type": "integer", "minimum": 1, "maximum": 300},
+        "secret_refs": {
+          "type": "object",
+          "description": "Map of param/header refs -> secret names",
+          "additionalProperties": {"type": "string"}
+        },
+        "extra": {
+          "type": "object",
+          "description": "Connector-specific extra configuration",
+          "additionalProperties": true
+        }
+      },
+      "additionalProperties": true
+    }
   }
 }
